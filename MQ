消息中间件（RocketMQ、Kafka）使用过程中避免不了的会遇到消息顺序消费的问题
1.消息顺序
  多Producer、多Partition或多Consumer的情况下，都可能出现因为网络延迟（消息未到达/消息到达超时确认）造成的消息丢失重传或后到消息先被消费的问题
  如果需要严格保证消费的顺序性，只能采取 One Producer - One Partition -> One Consumer 的形式(目前binlog消息需要保证严格的顺序性)
  a.单partition的问题：牺牲并发带来的性能提升；单点故障
2.重复消费
  部分情况下可能因为MQ延迟收到Consumer的确认消息，造成消息的重传(RockerMQ不保证消息不会重复发送)解决方法
  a.消费端对消息做幂等处理
  b.消费端消费消息的时候记录消息的id，在消息新的消息的时候查询消息id是否已经被消费过
3.事务消息
  事务消息主要是跨机器提交事务内容的时候，需要保持机器之间状态一致的场景，事务消息采用两段式事务提交方式
  a.发送prepare消息到MQ，MQ确认
  b.执行本地事务，事务成功或者回滚
  c.发送成功或者回滚消息给MQ，MQ发送执行消息给另一台机器或者取消MQ中消息
  异常：
  a.执行本地事务，发送给MQ时发送失败，解决方法：MQ会定期去轮训prepare状态的消息，保证消息能进入下一个状态(发送/取消)
  b.MQ收到本地事务执行成功消息，发送给另外一台机器执行时失败，解决方法：通过不断重试，保证消息发送成功
  c.另外一个机器收到消息，本地事务执行失败，回滚的情况，解决方法：人工干预，MQ不提供回滚方案

kafka 和 RocketMQ 原理上相似
数据路由到 partition 主要方式有两种，一种是消息随机分配到 partition 上，另外一种是通过 Hash 算法分配。
理论上，MQ是支持 partition 级别的顺序的，业务可以通过一些特征字段保证顺序
例如：
  订单的创建、完成和付费，可以通过 hash(id) 的方式，保证相同订单在同一个 partition，同时也能保证不同订单之间的并发。

kafka：消息重复消费、消息顺序性
  High Level(group 概念)
  a.客户端不需要记录offset，全部内容托管给zk
  b.同一个group内，消息不会被重复消费(客户端关闭瞬间没有提交offset到zk的情况排除)
  c.一个group可以订阅多个topic
  Low Level
  a.客户端自己管理offset和partition消费leader，好处是可以任意消费任何一个partition的任意段数据
  b.客户端需要自己做partition的balance，记录offset的值(offset频繁情况，可以写在内容，隔段时间/到达固定数值的情况下写一次)
